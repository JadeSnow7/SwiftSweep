import Foundation

// MARK: - BuildArtifactsRule

/// Detects build artifacts in project directories that can be safely deleted.
/// Scans common locations for project build outputs like .build/, node_modules/, dist/, target/, etc.
public struct BuildArtifactsRule: RecommendationRule {
  public let id = "build_artifacts"
  public let displayName = "Build Artifacts"
  public let capabilities: [RuleCapability] = [.cleanupItems]

  /// Minimum total size to trigger recommendation (bytes)
  private let minTotalSizeBytes: Int64 = 100_000_000  // 100 MB

  /// Build artifact directory patterns to scan
  /// Format: (displayName, directoryName, projectIndicator, severity)
  /// projectIndicator: file that indicates this is a valid project directory (to avoid false positives)
  private let artifactPatterns:
    [(name: String, dirName: String, projectIndicator: String?, severity: Severity)] = [
      // Swift/Xcode
      ("Swift Package Build", ".build", "Package.swift", .warning),
      ("Xcode Build", "build", "*.xcodeproj", .warning),
      ("DerivedData (Local)", "DerivedData", "*.xcodeproj", .warning),

      // JavaScript/Node
      ("Node Modules", "node_modules", "package.json", .info),
      ("Dist Output", "dist", "package.json", .info),
      ("Next.js Build", ".next", "package.json", .info),
      ("Nuxt Build", ".nuxt", "package.json", .info),
      ("Vite Build", ".vite", "vite.config.*", .info),

      // Python
      ("Python Cache", "__pycache__", "*.py", .info),
      ("Python Venv", ".venv", "requirements.txt", .info),
      ("Python Venv", "venv", "requirements.txt", .info),
      ("Pytest Cache", ".pytest_cache", "pytest.ini", .info),
      ("Python Eggs", "*.egg-info", "setup.py", .info),

      // Rust
      ("Rust Target", "target", "Cargo.toml", .warning),

      // Go
      ("Go Bin", "bin", "go.mod", .info),

      // Java/Kotlin
      ("Gradle Build", "build", "build.gradle*", .warning),
      ("Maven Target", "target", "pom.xml", .warning),

      // C/C++
      ("CMake Build", "build", "CMakeLists.txt", .info),
      ("CMake Cache", "CMakeFiles", "CMakeLists.txt", .info),
    ]

  /// Common project root directories to scan
  private let scanRoots: [String] = [
    "Developer",
    "Projects",
    "Code",
    "Workspace",
    "repos",
    "git",
    "src",
    "Documents/Developer",
    "Documents/Projects",
    "Documents/Code",
    "Desktop",
  ]

  public init() {}

  public func evaluate(context: RecommendationContext) async throws -> [Recommendation] {
    let fm = FileManager.default
    let home = fm.homeDirectoryForCurrentUser

    var foundArtifacts: [(name: String, path: String, size: Int64, severity: Severity)] = []

    // Scan each potential project root
    for rootRelative in scanRoots {
      let rootPath = home.appendingPathComponent(rootRelative)
      guard fm.fileExists(atPath: rootPath.path) else { continue }

      // Check cancellation
      if Task.isCancelled { return [] }

      // Scan for project directories (max depth 3 to avoid deep traversal)
      await scanForArtifacts(at: rootPath, depth: 0, maxDepth: 3, found: &foundArtifacts)
    }

    // Calculate total size
    let totalSize = foundArtifacts.reduce(0) { $0 + $1.size }

    // Only generate recommendation if total exceeds threshold
    guard totalSize >= minTotalSizeBytes else { return [] }

    // Sort by size descending
    foundArtifacts.sort { $0.size > $1.size }

    // Build evidence
    var evidence: [Evidence] = [
      Evidence(kind: .aggregate, label: "Total Build Artifacts", value: formatBytes(totalSize)),
      Evidence(kind: .aggregate, label: "Locations Found", value: "\(foundArtifacts.count)"),
    ]

    // Add top artifacts as evidence
    for artifact in foundArtifacts.prefix(8) {
      evidence.append(
        Evidence(
          kind: .path,
          label: artifact.name,
          value: formatBytes(artifact.size)
        ))
    }

    // Determine overall severity
    let overallSeverity: Severity =
      foundArtifacts.contains { $0.severity == .warning } ? .warning : .info

    // Build actions
    let paths = foundArtifacts.map { $0.path }
    let actions: [Action] = [
      Action(
        type: .cleanupTrash, payload: .paths(paths), requiresConfirmation: true,
        supportsDryRun: true)
    ]

    return [
      Recommendation(
        id: id,
        title: "Project Build Artifacts",
        summary:
          "\(foundArtifacts.count) build artifact directories totaling \(formatBytes(totalSize)). These can be regenerated by rebuilding your projects.",
        severity: overallSeverity,
        risk: .low,
        confidence: .high,
        estimatedReclaimBytes: totalSize,
        evidence: evidence,
        actions: actions,
        requirements: []
      )
    ]
  }

  // MARK: - Private Methods

  private func scanForArtifacts(
    at directory: URL,
    depth: Int,
    maxDepth: Int,
    found: inout [(name: String, path: String, size: Int64, severity: Severity)]
  ) async {
    guard depth <= maxDepth else { return }

    let fm = FileManager.default

    // Check if current directory contains any artifact directories
    for (name, dirName, projectIndicator, severity) in artifactPatterns {
      // Check cancellation
      if Task.isCancelled { return }

      let artifactPath = directory.appendingPathComponent(dirName)

      // Check if artifact directory exists
      var isDir: ObjCBool = false
      guard fm.fileExists(atPath: artifactPath.path, isDirectory: &isDir), isDir.boolValue else {
        continue
      }

      // Verify project indicator exists (if specified) to avoid false positives
      if let indicator = projectIndicator {
        let hasIndicator = checkProjectIndicator(in: directory, pattern: indicator)
        guard hasIndicator else { continue }
      }

      // Calculate size
      let size = calculateDirectorySize(at: artifactPath)
      if size > 10_000_000 {  // Only include if > 10MB
        // Create a descriptive name
        let projectName = directory.lastPathComponent
        let displayName = "\(name) (\(projectName))"
        found.append((displayName, artifactPath.path, size, severity))
      }
    }

    // Recurse into subdirectories (but skip artifact directories themselves)
    guard depth < maxDepth else { return }

    do {
      let contents = try fm.contentsOfDirectory(
        at: directory,
        includingPropertiesForKeys: [.isDirectoryKey],
        options: [.skipsHiddenFiles]
      )

      for item in contents {
        // Check cancellation
        if Task.isCancelled { return }

        let resourceValues = try? item.resourceValues(forKeys: [.isDirectoryKey])
        guard resourceValues?.isDirectory == true else { continue }

        // Skip common artifact directory names to avoid deep scanning
        let name = item.lastPathComponent
        let skipNames = Set([
          "node_modules", ".build", "build", "target", "dist", ".next", ".nuxt",
          "__pycache__", ".venv", "venv", ".git", ".svn", "Pods", "Carthage",
        ])
        guard !skipNames.contains(name) else { continue }

        await scanForArtifacts(at: item, depth: depth + 1, maxDepth: maxDepth, found: &found)
      }
    } catch {
      // Ignore access errors
    }
  }

  private func checkProjectIndicator(in directory: URL, pattern: String) -> Bool {
    let fm = FileManager.default

    // Handle wildcard patterns
    if pattern.contains("*") {
      do {
        let contents = try fm.contentsOfDirectory(atPath: directory.path)
        let regex = pattern.replacingOccurrences(of: ".", with: "\\.").replacingOccurrences(
          of: "*", with: ".*")
        for file in contents {
          if file.range(of: "^\(regex)$", options: .regularExpression) != nil {
            return true
          }
        }
      } catch {
        return false
      }
      return false
    } else {
      // Exact match
      let indicatorPath = directory.appendingPathComponent(pattern)
      return fm.fileExists(atPath: indicatorPath.path)
    }
  }

  private func calculateDirectorySize(at url: URL) -> Int64 {
    let fm = FileManager.default
    var size: Int64 = 0

    guard
      let enumerator = fm.enumerator(
        at: url, includingPropertiesForKeys: [.fileSizeKey], options: [.skipsHiddenFiles])
    else {
      return 0
    }

    for case let fileURL as URL in enumerator {
      if let resourceValues = try? fileURL.resourceValues(forKeys: [.fileSizeKey]),
        let fileSize = resourceValues.fileSize
      {
        size += Int64(fileSize)
      }
    }

    return size
  }

  private func formatBytes(_ bytes: Int64) -> String {
    let gb = Double(bytes) / 1_000_000_000
    if gb >= 1 {
      return String(format: "%.1f GB", gb)
    }
    let mb = Double(bytes) / 1_000_000
    return String(format: "%.1f MB", mb)
  }
}
