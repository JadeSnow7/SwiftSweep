import Foundation

// MARK: - Recommendation

/// A structured recommendation generated by the engine.
/// Contains evidence, actions, and metadata for UI/CLI presentation.
public struct Recommendation: Identifiable, Equatable, Sendable, Codable {
  public let id: String
  public let title: String
  public let summary: String
  public let severity: Severity
  public let risk: RiskLevel
  public let confidence: Confidence
  public let estimatedReclaimBytes: Int64?
  public let estimatedPerformanceImpact: String?
  public let evidence: [Evidence]
  public let actions: [Action]
  public let requirements: [Requirement]

  public init(
    id: String,
    title: String,
    summary: String,
    severity: Severity = .info,
    risk: RiskLevel = .low,
    confidence: Confidence = .medium,
    estimatedReclaimBytes: Int64? = nil,
    estimatedPerformanceImpact: String? = nil,
    evidence: [Evidence] = [],
    actions: [Action] = [],
    requirements: [Requirement] = []
  ) {
    self.id = id
    self.title = title
    self.summary = summary
    self.severity = severity
    self.risk = risk
    self.confidence = confidence
    self.estimatedReclaimBytes = estimatedReclaimBytes
    self.estimatedPerformanceImpact = estimatedPerformanceImpact
    self.evidence = evidence
    self.actions = actions
    self.requirements = requirements
  }
}

// MARK: - Severity

public enum Severity: String, Equatable, Sendable, Codable, CaseIterable {
  case info = "info"
  case warning = "warning"
  case critical = "critical"

  public var displayName: String {
    switch self {
    case .info: return "Info"
    case .warning: return "Warning"
    case .critical: return "Critical"
    }
  }

  public var sortOrder: Int {
    switch self {
    case .critical: return 0
    case .warning: return 1
    case .info: return 2
    }
  }
}

// MARK: - RiskLevel

public enum RiskLevel: String, Equatable, Sendable, Codable, CaseIterable {
  case low = "low"
  case medium = "medium"
  case high = "high"

  public var displayName: String {
    switch self {
    case .low: return "Low Risk"
    case .medium: return "Medium Risk"
    case .high: return "High Risk"
    }
  }
}

// MARK: - Confidence

public enum Confidence: String, Equatable, Sendable, Codable, CaseIterable {
  case low = "low"
  case medium = "medium"
  case high = "high"

  public var displayName: String {
    switch self {
    case .low: return "Low Confidence"
    case .medium: return "Medium Confidence"
    case .high: return "High Confidence"
    }
  }
}

// MARK: - Evidence

/// Evidence explaining why a recommendation was generated.
public struct Evidence: Equatable, Sendable, Codable {
  public let kind: EvidenceKind
  public let label: String
  public let value: String

  public init(kind: EvidenceKind, label: String, value: String) {
    self.kind = kind
    self.label = label
    self.value = value
  }
}

public enum EvidenceKind: String, Equatable, Sendable, Codable {
  case path = "path"  // File/directory path
  case metric = "metric"  // System metric (CPU, disk, memory)
  case metadata = "metadata"  // File metadata (creation date, last used)
  case aggregate = "aggregate"  // Aggregated statistics
}

// MARK: - Action

/// An executable action associated with a recommendation.
public struct Action: Equatable, Sendable, Codable {
  public let type: ActionType
  public let payload: ActionPayload
  public let requiresConfirmation: Bool
  public let supportsDryRun: Bool

  public init(
    type: ActionType,
    payload: ActionPayload,
    requiresConfirmation: Bool = true,
    supportsDryRun: Bool = true
  ) {
    self.type = type
    self.payload = payload
    self.requiresConfirmation = requiresConfirmation
    self.supportsDryRun = supportsDryRun
  }
}

public enum ActionType: String, Equatable, Sendable, Codable {
  case cleanupDelete = "cleanupDelete"  // Permanently delete
  case cleanupTrash = "cleanupTrash"  // Move to trash (safer)
  case emptyTrash = "emptyTrash"  // Empty the Trash
  case optimizeTask = "optimizeTask"  // Run optimization task
  case openFinder = "openFinder"  // Reveal in Finder
  case uninstallPlan = "uninstallPlan"  // Invoke uninstall engine
  case rescan = "rescan"  // Re-run analysis
}

public enum ActionPayload: Equatable, Sendable, Codable {
  case paths([String])  // For cleanup/openFinder
  case optimizationTask(String)  // Task type identifier
  case bundleID(String)  // For uninstall
  case none  // For rescan

  // Custom Codable implementation for enum with associated values
  private enum CodingKeys: String, CodingKey {
    case type, value
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    let type = try container.decode(String.self, forKey: .type)

    switch type {
    case "paths":
      let value = try container.decode([String].self, forKey: .value)
      self = .paths(value)
    case "optimizationTask":
      let value = try container.decode(String.self, forKey: .value)
      self = .optimizationTask(value)
    case "bundleID":
      let value = try container.decode(String.self, forKey: .value)
      self = .bundleID(value)
    default:
      self = .none
    }
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)

    switch self {
    case .paths(let paths):
      try container.encode("paths", forKey: .type)
      try container.encode(paths, forKey: .value)
    case .optimizationTask(let task):
      try container.encode("optimizationTask", forKey: .type)
      try container.encode(task, forKey: .value)
    case .bundleID(let id):
      try container.encode("bundleID", forKey: .type)
      try container.encode(id, forKey: .value)
    case .none:
      try container.encode("none", forKey: .type)
    }
  }
}

// MARK: - Requirement

/// Capability or permission required to execute a recommendation.
public enum Requirement: String, Equatable, Sendable, Codable {
  case helperInstalled = "helperInstalled"  // Needs privileged helper
  case directoryAccess = "directoryAccess"  // Needs user-selected directory
  case fullDiskAccess = "fullDiskAccess"  // Needs FDA entitlement
}
