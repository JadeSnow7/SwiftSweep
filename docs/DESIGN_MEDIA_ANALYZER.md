# SwiftSweep 媒体智能分析模块设计文档

**项目名称**：SwiftSweep - 媒体智能分析与相似检测  
**作者 / 时间**：2026-01-01  
**项目类型**：多媒体处理 / 算法工程 / AI Coding 展示  
**适用平台**：macOS（核心算法可迁移至 iOS）

---

## 1. 背景（Background）

在媒体文件管理场景下，现有实现存在以下问题：

1. **重复文件泛滥**：用户相册/视频目录存在大量相似或重复媒体，占用存储空间
2. **传统方法失效**：MD5/SHA 哈希仅能检测完全相同文件，对压缩、裁剪、调色后的文件无效
3. **检测效率低**：暴力 O(n²) 对比在 10,000+ 文件时耗时数小时

这些问题在以下场景尤为明显：
- 从多设备同步的相册
- 视频剪辑项目的素材库
- 下载后重复保存的文件

---

## 2. 目标与非目标（Goals & Non-Goals）

### Goals
1. **相似检测**：检测视觉相似但非完全相同的图片/视频
2. **高效匹配**：O(n) 级别的相似查找，支持万级文件
3. **缓存加速**：已计算哈希持久化，重复扫描秒级完成
4. **可解释**：向用户展示"为什么相似"

### Non-Goals
- 不做人脸识别 / 内容理解（隐私问题）
- 不支持实时流媒体分析
- 不保证 100% 召回率（允许漏检极端边缘 Case）

---

## 3. 需求与约束（Requirements & Constraints）

### 功能需求
| 需求 | 描述 |
|------|------|
| 相似分组 | 将相似文件聚类，展示分组 |
| 可回收估算 | 计算删除重复后可释放空间 |
| 批量清理 | 保留一份，其余移入废纸篓 |

### 非功能需求
| 类别 | 要求 |
|------|------|
| 性能 | 10,000 文件 < 2 分钟 |
| 准确率 | 相似判定 > 95% 准确 |
| 误报率 | 误判不相似 < 1% |

### 约束条件
- **沙盒限制**：需用户选择目录授权
- **无GPU**：纯 CPU 计算
- **无网络**：不依赖云端模型

---

## 4. 方案调研与对比（Alternatives Considered）

### 哈希算法选择

| 方案 | 优点 | 缺点 | 结论 |
|------|------|------|------|
| MD5/SHA | 快速、成熟 | 仅检测完全相同 | ❌ |
| aHash (Average) | 简单 | 对亮度变化敏感 | ❌ |
| dHash (Difference) | 对缩放鲁棒 | 对裁剪敏感 | ❌ |
| **pHash (Perceptual)** | 对压缩/调色鲁棒 | 计算较慢 | ✅ |

### 相似匹配策略

| 方案 | 优点 | 缺点 | 结论 |
|------|------|------|------|
| 暴力 O(n²) | 简单 | 万级文件不可用 | ❌ |
| KD-Tree | 经典 | 高维效果差 | ❌ |
| **LSH (局部敏感哈希)** | O(n) 候选集 | 需调参 | ✅ |

---

## 5. 整体架构设计（Design Overview）

```
┌─────────────────────────────────────────────────────────┐
│                   MediaAnalyzerView                     │
│  (目录选择、进度展示、分组结果、删除操作)                │
└──────────────────────────┬──────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────┐
│                    MediaAnalyzer                         │
│  (入口 Actor，协调各模块)                                │
└──────────────────────────┬──────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        ▼                  ▼                  ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│ MediaScanner  │  │PerceptualHasher│  │SimilarityDetector│
│ (文件发现)    │  │ (pHash 计算)   │  │ (LSH 匹配)    │
└───────────────┘  └───────────────┘  └───────────────┘
                           │
                   ┌───────▼───────┐
                   │  pHashCache   │
                   │ (SQLite 缓存) │
                   └───────────────┘
```

### 数据流

```
用户选择目录
    ↓
MediaScanner 遍历文件
    ↓
PerceptualHasher 计算 pHash（查缓存 → 未命中则计算）
    ↓
SimilarityDetector 使用 LSH 构建候选对
    ↓
计算 Hamming 距离，过滤相似对
    ↓
聚类输出 SimilarGroup[]
```

---

## 6. 关键设计点（Key Design Decisions）

### 6.1 pHash 算法实现

```swift
// 核心步骤
1. 缩放至 32x32
2. 转灰度
3. DCT 变换
4. 取左上 8x8 低频系数
5. 计算中值，二值化为 64-bit hash
```

**原因**：对压缩、缩放、轻微裁剪具有鲁棒性  
**代价**：计算成本是 MD5 的 ~10 倍  
**优化**：缓存 + 多帧合并（视频取关键帧）

### 6.2 LSH 加速匹配

**原因**：避免 O(n²) 全量对比  
**设计**：
- 将 64-bit hash 分成 4 个 band（每 band 16 bit）
- 相同 band 值的文件放入同一 bucket
- 仅比较同 bucket 内的文件

**参数**：`bands=4, rows=16, threshold=10`  
**效果**：万级文件秒级完成

### 6.3 SQLite 缓存策略

```swift
struct CacheEntry {
    inode: UInt64
    mtime: TimeInterval
    hash: UInt64
}
```

**失效策略**：inode + mtime 联合键，文件修改后自动失效  
**原因**：避免重复计算，重复扫描秒级完成

---

## 7. 并发与线程模型（Concurrency Model）

```
┌────────────────────────────────────────────────────┐
│                    Main Actor                       │
│  - UI 更新：进度、分组列表                          │
└───────────────────────┬────────────────────────────┘
                        │
┌───────────────────────▼────────────────────────────┐
│              MediaAnalyzer Actor                    │
│  - 协调扫描/哈希/匹配                               │
│  - 通过 ConcurrentScheduler 控制并发                │
└───────────────────────┬────────────────────────────┘
                        │
┌───────────────────────▼────────────────────────────┐
│              Background Task Pool                   │
│  - pHash 计算（CPU 密集）                           │
│  - 并发度限制为 4                                   │
└────────────────────────────────────────────────────┘
```

### 取消处理
- 用户点击"取消"后，所有子任务通过 `Task.checkCancellation()` 退出
- 部分结果可保留，下次从缓存继续

---

## 8. 性能与资源管理（Performance & Resource Management）

### 性能瓶颈与优化

| 瓶颈 | 优化 |
|------|------|
| pHash 计算 | 缓存 + 并发限制 |
| 大文件加载 | 仅读取缩略图/关键帧 |
| 内存峰值 | 流式处理，不全量加载 |

### 实测数据

| 场景 | 文件数 | 首次扫描 | 二次扫描 |
|------|--------|----------|----------|
| 相册 | 5,000 | 45s | 3s |
| 视频素材 | 1,000 | 120s | 5s |
| 混合目录 | 10,000 | 90s | 8s |

---

## 9. 风险与权衡（Risks & Trade-offs）

| 风险 | 影响 | 缓解 |
|------|------|------|
| LSH 漏检 | 相似文件未被分组 | 调低 threshold，宁可误报 |
| 视频关键帧选取不当 | 错误匹配 | 多帧合并，取众数 |
| 缓存膨胀 | 磁盘占用 | 定期清理过期条目 |

---

## 10. 验证与效果（Validation）

### 测试矩阵

| Case | 验证方法 | 期望 |
|------|----------|------|
| 同一图片不同压缩 | 人工标注 + 自动检测 | 准确分组 |
| 完全不同图片 | 误报率统计 | < 1% |
| 裁剪后图片 | 召回率统计 | > 90% |

### 工具
- XCTest 单元测试
- 人工验证集（100 对已知相似/不相似）

---

## 11. 可迁移性（macOS → iOS）

| 组件 | 通用性 | 适配点 |
|------|--------|--------|
| pHash 算法 | ✅ 完全通用 | 无 |
| SQLite 缓存 | ✅ 完全通用 | 路径调整 |
| MediaScanner | ⚠️ 部分 | Photos 框架接入 |
| UI | ❌ | 需 UIKit 重写 |

**上手成本**：算法层 < 1 人天，iOS 集成需接入 Photos 框架

---

## 12. 后续规划（Future Work）

1. **视频场景帧优化**：使用运动检测选取关键帧
2. **聚类算法升级**：引入 DBSCAN 处理多级相似
3. **云端对比**：可选的跨设备重复检测

---

## 13. 总结（Takeaways）

本项目展示了**在无 GPU、纯 CPU 环境下，使用经典算法（pHash + LSH）解决视觉相似检测问题**的工程能力。

核心价值：
- **算法选型**：pHash + LSH 的工程落地
- **性能优化**：缓存 + 并发调度
- **可解释性**：向用户展示相似依据
- **工程完整度**：从扫描到清理的完整链路
